import 'dart:convert';

class BibleVersion {
  int id;

  ///default `[pt-br]`
  String? language;

  ///name of the bible version
  String versionName;

  ///version versionAbrev need to be unique for his language
  ///
  ///this field is used + [language] to generate the [hash]
  String versionAbrev;
  String? copyright;

  ///default `false`
  ///
  ///need to be `true` if the bible version has lexico version
  bool? hasStrong;

  ///hash is not optional
  ///
  ///generated by `versionAbrev + language`
  ///
  ///need to be **unique**. NLP relly on this hash to search the bible version
  ///
  ///this is created because other users can create bible versions modules and [id] is autoincrement by the database
  ///
  ///```dart
  ///getHashBibleVersion({required String abrev, required String language}) {
  ///   var bytes = utf8.encode('$abrev$language');
  ///   var hash = md5.convert(bytes).toString();
  ///   return hash;
  ///}
  ///```
  String? hash;
  BibleVersion({
    this.id = 0,
    this.language = 'pt-br',
    required this.versionName,
    required this.versionAbrev,
    this.copyright,
    this.hasStrong = false,
    this.hash,
  });

  BibleVersion copyWith({
    int? id,
    String? language,
    String? versionName,
    String? versionAbrev,
    String? copyright,
    bool? hasStrong,
    String? hash,
  }) {
    return BibleVersion(
      id: id ?? this.id,
      language: language ?? this.language,
      versionName: versionName ?? this.versionName,
      versionAbrev: versionAbrev ?? this.versionAbrev,
      copyright: copyright ?? this.copyright,
      hasStrong: hasStrong ?? this.hasStrong,
      hash: hash ?? this.hash,
    );
  }

  Map<String, dynamic> toMap() {
    final result = <String, dynamic>{};

    result.addAll({'id': id});
    if (language != null) {
      result.addAll({'language': language});
    }
    result.addAll({'versionName': versionName});
    result.addAll({'versionAbrev': versionAbrev});
    if (copyright != null) {
      result.addAll({'copyright': copyright});
    }
    if (hasStrong != null) {
      result.addAll({'hasStrong': hasStrong});
    }
    if (hash != null) {
      result.addAll({'hash': hash});
    }

    return result;
  }

  factory BibleVersion.fromMap(Map<String, dynamic> map) {
    try {
      return BibleVersion(
        id: map['id']?.toInt() ?? 0,
        language: map['language'],
        versionName: map['versionName'] ?? '',
        versionAbrev: map['versionAbrev'] ?? '',
        copyright: map['copyright'],
        hasStrong: map['hasStrong'],
        hash: map['hash'],
      );
    } catch (e) {
      throw Exception('Error parsing BibleVersion.fromMap: $e\nMap: $map');
    }
  }

  String toJson() => json.encode(toMap());

  factory BibleVersion.fromJson(String source) =>
      BibleVersion.fromMap(json.decode(source));

  @override
  String toString() {
    return 'BibleVersion(id: $id, language: $language, versionName: $versionName, versionAbrev: $versionAbrev, copyright: $copyright, hasStrong: $hasStrong, hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is BibleVersion &&
        other.id == id &&
        other.language == language &&
        other.versionName == versionName &&
        other.versionAbrev == versionAbrev &&
        other.copyright == copyright &&
        other.hasStrong == hasStrong &&
        other.hash == hash;
  }

  @override
  int get hashCode {
    return id.hashCode ^
        language.hashCode ^
        versionName.hashCode ^
        versionAbrev.hashCode ^
        copyright.hashCode ^
        hasStrong.hashCode ^
        hash.hashCode;
  }
}
